
// Do not edit this file function (use only)
// add this file in source/External file
// add source_Genaral.c in your source
// #include"general.h" in your program
// #include"date.h" in your program
#pragma once 
/// no error
#pragma warning (push, 4)
#pragma warning (disable : 4204 4996)

#include<sal.h>
#include<stdio.h>
#include<string.h>
#include<corecrt.h>
#include"general.h"

#ifndef GROUP_USE_FUNCTION_INLINE

	#ifndef DATE_STRUCT_DEFINED
	#define DATE_STRUCT_DEFINED

	typedef struct Struct_date {
		int  day;
		int  month;
		int  year;
		char sddmmyyyy[11];
		char sTime[11];
		int  minute;
		int  hours;
	}DateTime;
	static DateTime const NULL_DATETIME = { 0,0,0,"00/00/0000","00:00xx",0,0 };

	#endif // !DATE_STRUCT_DEFINED

#define ISSAME_STR !
#define TRUE       1
#define FALSE      0
#define NO_CHANGE  (-1)

#endif // !GROUP_USE_FUNCTION_INLINE

/*******************************************
*
*                   DATE
*
*******************************************/

// get function //
void get_In_fDate(
	const char     * const dateName,
	DateTime       * date
);
void get_In_Date(
	const char     * const dateName,
	DateTime       * date
);
void get_str_Date(
	DateTime *date
);
void get_Date_read_str(
	DateTime * date
);

// calculate function  //
void cal_Date(
	DateTime * cal,
	const int  addDay
);

// check function //
__crt_bool isDate(
	const DateTime date
);

// Compare function //
__crt_bool cmpDate(
	const DateTime *date1,
	const DateTime *date2
);

/*******************************************
*
*                   TIME
*
*******************************************/

// get function //
void get_Time_read_str(
	DateTime * time
);
void get_str_Time(
	DateTime * time
);

// calculate function  //
void cal_Time(
	DateTime * cal,
	const int  addMinute,
	const int  addHour
);

// check function //
__crt_bool isTime(
	const DateTime *date1
);
__crt_bool isOpenTime(
	const DateTime *date1
);

// Compare function //
__crt_bool cmpTime(
	const DateTime *time1,
	const DateTime *time2
);

/*******************************************
*
*                 DATE TIME
*
*******************************************/

// Constructor/Assgin function //
DateTime new_Date(
	const int day,
	const int month,
	const int year
);
DateTime new_sDateTime(
	const char * date
);
/************************************************************************
*                                                                       *
*				    BOOLEAN FUNCTION DEFINATION AREA                    *
*                                                                       *
*************************************************************************/
// in C bool is cant work __crt_bool is the best
// start with 'is', return __crt_bool only
// NO_CHANGE is unfunction
__crt_bool cmpTime(
	const DateTime *time1, 
	const DateTime *time2)
{
	return (
		time1->hours == time2->hours &&
		time1->minute == time2->minute ?
		TRUE : FALSE);
}
__crt_bool cmpDate(
	const DateTime *date1, 
	const DateTime *date2)
{
	return (
		date1->day == date2->day &&
		date1->month == date2->month &&
		date1->year == date2->year ?
		TRUE : FALSE);
}
__crt_bool isOpenTime(
	const DateTime *date1)
{
	// 10:00 am until (9:59~10:00) pm is clinic open time
	if (isRange(10, 21, date1->hours) && isRange(0, 60, date1->minute))
		return TRUE;
	else
		return FALSE;
}
__crt_bool isTime(
	const DateTime *date1)
{
	return (
		isRange(0, 60, date1->minute) &&
		isRange(0, 24, date1->hours) ?
		TRUE : FALSE);
}
__crt_bool isDate(
	const DateTime  date)
{
	// if year or month not in range return false direct
	if (!isRange(1900, 2500, date.year) || !isRange(1, 12, date.month))
		return FALSE;

	if ((date.month == 1 || date.month == 3 || date.month == 5 ||
		date.month == 7 || date.month == 8 || date.month == 10 ||
		date.month == 12) && isRange(1, 31, date.day))
		return TRUE;          // check month have 31 day
	else if ((date.month == 4 || date.month == 6 || date.month == 9
		|| date.month == 11) && isRange(1, 30, date.day))
		return TRUE;          // check month have 30 day

	if ((date.year % 4 == 0 && date.year % 100 != 0) ||
		(date.year % 400 == 0))
	{
		//Leap Year month(FEB) have up to 29 day
		if (isRange(1, 29, date.day) && date.month == 2)
			return TRUE;
	}
	else
	{
		//not Leap Year month(FEB) is 28 day only
		if (isRange(1, 28, date.day) && date.month == 2)
			return TRUE;
	}
	// if not match to upper part will return FALSE
	return FALSE;
}
/************************************************************************
*                                                                       *
*				 STREAM In/Out FUNCTION DEFINATION AREA                 *
*				    & GET FUNCTION DEFINATION AREA                      *
*                                                                       *
*************************************************************************/
void get_str_Date(
	DateTime * date)
{
	// use sprintf to print format and save in to string
	sprintf(date->sddmmyyyy, "%02d/%02d/%04d",
		date->day, date->month, date->year);
}
void get_str_Time(
	DateTime * time)
{
	if (time->hours == 12)
		sprintf(time->sTime, "%02d:%02dpm",
		12, time->minute);
	else if (time->hours == 24 || time->hours == 0)
		sprintf(time->sTime, "%02d:%02dam",
		0, time->minute);
	else if (isRange(13, 23, time->hours))
		sprintf(time->sTime, "%02d:%02dpm",
		(time->hours % 12), time->minute);
	else if (isRange(1, 11, time->hours))
		sprintf(time->sTime, "%02d:%02dam",
		(time->hours), time->minute);
	else
		*time = NULL_DATETIME;
}
// NON KEYBOARD AREA
void get_Date_read_str(
	DateTime * date)
{
	int i;
	char format[21] = "";
	__crt_bool check = FALSE;
		__crt_bool finalCheck = FALSE;
	const char character[6] = { '/', '-', '.', ' ', ',', '\\' };
	for (i = 0; i < 6; i++)
	{
		check =
			(*(date->sddmmyyyy + 2) == character[i] ||
			 *(date->sddmmyyyy + 1) == character[i]) &&
			(*(date->sddmmyyyy + 5) == character[i] ||
			 *(date->sddmmyyyy + 4) == character[i] ||
			 *(date->sddmmyyyy + 3) == character[i]);
		if (check)
		{
			sprintf(format, "%%d%c%%d%c%%d", character[i], character[i]);
			finalCheck = TRUE;
			break;
		}
	}
	// make sure the string is in format
	if (finalCheck)
		sscanf(date->sddmmyyyy, format, &date->day, &date->month, &date->year);
	else
		*date = NULL_DATETIME;
	get_str_Date(date);
}
void get_Time_read_str(
	DateTime * time)
{
	__crt_bool check =
		*(time->sTime + 2) == ':' ||
		*(time->sTime + 1) == ':';
	char temp3[10] = "";
	if (check)
	{
		sscanf(time->sTime, "%d:%d%s", &time->hours, &time->minute, temp3);
		if (ISSAME_STR strncmp(temp3, "pm", 2) &&
			(time->hours == 12 || time->hours == 0))
			time->hours = 12;
		else if (ISSAME_STR strncmp(temp3, "am", 2) &&
			(time->hours == 12 || time->hours == 0))
			time->hours = 0;
		else if (ISSAME_STR strncmp(temp3, "pm", 2) &&
			isRange(1, 11, time->hours))
			time->hours += 12;
		else if (ISSAME_STR strncmp(temp3, "am", 2) &&
			isRange(1, 11, time->hours))
			time->hours;
		else if (ISSAME_STR strncmp(temp3, "", 1) &&
			isRange(0, 24, time->hours))
			time->hours;
		else
			*time = NULL_DATETIME;

		// get the updated string is correct format
		get_str_Time(time);
	}
	else
		*time = NULL_DATETIME;
}
void get_In_Date(
	const char * const dateName, 
	DateTime * date)
{
	date->day = get_In_intf_rtn(  "Please Enter The %s day   : ", dateName);
	date->month = get_In_intf_rtn("Please Enter The %s month : ", dateName);
	date->year = get_In_intf_rtn( "Please Enter The %s year  : ", dateName);
	get_str_Date(date);
}
// get user in version dd/mm/yyyy
void get_In_fDate(
	const char * const dateName, 
	DateTime * date)
{
	out_MessageBox("|         Enter In Format (dd/mm/yyyy)        |");
	get_In_stringf(date->sddmmyyyy, "Please Enter %s Date  : ", dateName);
	get_Date_read_str(date);
}
// no check Date vaildation
DateTime new_Date(
	const int day,
	const int month, 
	const int year)
{
	DateTime date = { day,month,year,"","",0,0 };
	get_str_Date(&date);
	return date;
}
// no check Date vaildation
DateTime new_sDateTime(
	const char * date)
{
	int count = 0;
	__crt_bool timeUsing = FALSE;
	DateTime result = NULL_DATETIME;
	while (*(date + count) != '\0')
	{
		if (*(date + count) == '-')
		{
			timeUsing = TRUE;
			break;
		}
		count++;
	}

	if (timeUsing)
	{
		sscanf(date, "%[^-]-%s", result.sddmmyyyy, result.sTime);
		get_Time_read_str(&result);
	}
	else
	{
		sscanf(date, "%s", result.sddmmyyyy);
	}
	get_Date_read_str(&result);
	return result;
}
/************************************************************************
*                                                                       *
*			      cal_ FUNCTION CALL DEFINITION AREA                    *
*                                                                       *
*************************************************************************/
// cal_ function // 
// get data and count and return(parameter / return)
void cal_Time(
	DateTime * cal,
	const int addMinute, 
	const int addHour)
{
	int addDay = 0;
	if (isTime(cal))
	{
		cal->hours += addHour;
		cal->minute += addMinute;
		do
		{
			if (cal->minute >= 60)
			{
				cal->minute -= 60;
				cal->hours += 1;
			}
			if (cal->hours >= 24)
			{
				cal->hours -= 24;
				addDay++;
			}
		} while (!isTime(cal));
		cal_Date(cal, addDay);
		get_str_Time(cal);
		get_str_Date(cal);
	}
	else
		*cal = NULL_DATETIME;
}
// Date Must Be A Valid Value
void cal_Date(
	_Out_ DateTime * cal, 
	_In_ const int addDay)
{
	const int day[13] = {
		0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
	// if pass not date will effect the result not accurate
	if (isDate(*cal) && addDay > 0)
	{
		cal->day += addDay;
		do {
			if (cal->month == 2)
			{
				// this if statment mean not leap year
				if (!isDate(new_Date(29, 2, cal->year)) 
					&& (cal->day > 28))
				{
					// not leap year
					cal->day -= 28;
					cal->month++;
				}
				else if (cal->day > 29)
				{
					// leap year
					cal->day -= 29;
					cal->month++;
				}
			}
			else if ((cal->month != 2) && 
				isRange(1, 12, cal->month))
			{
				// count all the month accept feb use array
				if (cal->day > day[cal->month])
				{
					cal->day -= day[cal->month];
					cal->month++;
				}
			}
			// 
			if (cal->month > 12)
			{
				cal->month -= 12;
				cal->year++;
			}
		} while (!isDate(*cal));
		// change date in string
		get_str_Date(cal);
	}
	else if (isDate(*cal) && addDay < 0)
	{
		cal->day += addDay;
		do {
			if (cal->month == 3)
			{
				// this if statment mean not leap year
				if (!isDate(new_Date(29, 2, cal->year)) && 
					(cal->day < 1))
				{
					// not leap year
					cal->day += 28;
					cal->month--;
				}
				else if (cal->day < 1)
				{
					// leap year
					cal->day += 29;
					cal->month--;
				}
			}
			else if ((cal->month != 3) && 
				isRange(1, 12, cal->month))
			{
				// count all the month accept feb use array
				if (cal->day < 1)
				{
					cal->day += day[cal->month - 1];
					cal->month--;
				}
			}

			if (cal->month <= 1)
			{
				cal->month += 12;
				cal->year--;
			}
		} while (!isDate(*cal));
		// change date in string
		get_str_Date(cal);
	}
	else if (isDate(*cal) && addDay == 0)
	{
		// when add date == 0 no change will make
	}
	else
		*cal = NULL_DATETIME;
}
#pragma warning (pop)
